
#______________________________________________________________________________

MultivariateHawkesLambdaValue<-function(time,history,sub_process,mu,alpha,beta)
{
  #Calulate the lambda value of each coordinate at time seconds 
  #value is 1xM matrix to store ambda value of each process
  M<- dim(mu)[1]
  value<- mu;
  history_before_time<- history[history<=time,];
  sub_process_before_time<- list();
  
  #trim the sub_process to the length before time
  for(m in 1:M)
  {
    #coerce as matrix
    temp<- sub_process[[m]][sub_process[[m]]<=time,];
    temp_dim<- length(temp);
    if(temp_dim==0)
    {
      sub_process_before_time[[m]]<- array(0,dim=c(1,1))
    }
    else
    {
      sub_process_before_time[[m]]<- array(temp,dim=c(temp_dim,1))
    }
  }
  
  if(time<history[1,1]){
    #if time is smaller than the first event, the lambda will be mu
    value<-mu;
    return (value);
  }
  else{
    for(m in 1:M){
      #for lambda m
      for(j in 1:M){
        #for calculating stimulation of sub_process j 
        for(i in 1:dim(sub_process_before_time[[j]])[1]){
          value[m,1]=value[m,1]+alpha[m,j]*exp(-beta[m,j]*(time-sub_process_before_time[[j]][i,1]));
        }
        
      }
    }
    print(value)
    return (value);
  }
}

MultivariateHawkesSimulation<-function(mu,alpha,beta,T,history=list()){
  
  #simulate a multivariate hawkes process given the history events
  #mu:            background intensity M x 1 matrix
  #history:       If history is not provided(history = 0), the default simulation starts from 0
  #alpha,beta:    M x M matrix, with rows i being the parameters of process i
  #T:             scalar, end time of simulation
  
  #M:             total number of sub processes
  M<-dim(mu)[1];
  
  #Initialization:
  if(length(history)==0){
    
    total_index<-1;sub_index<-array(1,dim=c(1,M));
    total_intensity<-sum(mu);
    
    #First Event
    s<--log(runif(1))/total_intensity;
    print(s)
    #t:Store event time:        
    t<-array(0,dim=c(1,1));
    
    #sub_process stores the sub history of each process
    sub_process<-list();
    n0=0;
    for(m in 1:M){
      sub_process[[m]]<-array(0,dim=c(1,1));
    }
    
    if(s>T){return (list(t,sub_process));}
    
    #Attribution test
    randomD<-runif(1);
    if(mu[1,1]/total_intensity>=randomD){
      t[1,1]<-s;
      sub_process[[1]][1,1]<-s;
      n0<-1;
    }
    else{
      for(j in 2:M){
        if ((sum(mu[c(1:j-1),1])/total_intensity<randomD)
            &&(sum(mu[c(1:j),1])/total_intensity>=randomD)){
          t[1,1]<-s;
          sub_process[[j]][1,1]<-s;
          n0<-j;
        }
      }
    }
    
    #Update the index
    total_index<-total_index+1;
    sub_index[1,n0]<-sub_index[1,n0]+1;
    
  }
  else{
    #If history is provided, continue simulation from the history
    
    t=history[[1]]
    sub_process<-list();
    
    #total index counts the number of total events
    #sub index counts the number of sub-process
    
    total_index=dim(t)[1];
    sub_index<-array(1,dim=c(1,M));
    
    n0=0;
    s=t[total_index,1];
    for(m in 1:M){
      sub_process[[m]]<-history[[2]][[m]];
      sub_index[1,m]=dim(sub_process[[m]])[1];
    }
    
    #Set the termination time
    T=t[total_index,1]+T;
    total_index=total_index+1;
  }
  
  #General Routine
  out_range<-FALSE;
  while(out_range==FALSE){
    
    total_intensity<-sum(MultivariateHawkesLambdaValue(t[total_index-1,1],t,sub_process,mu,alpha,beta))+sum(alpha[,n0]);
    
    #Sample a exponential r.v 
    #If X has a standard uniform distribution, Y = − ln(X) / λ has an exponential distribution with rate λ
    s<-s-log(runif(1))/total_intensity;
    print(s)
    #If the sampled r.v is larger than the required length T
    if(s>T){break;}
    
    while(out_range==FALSE){
      
      #Attribution - Rejection test
      value=MultivariateHawkesLambdaValue(s,t,sub_process,mu,alpha,beta);
      intensity_s=sum(value);
      randomD=runif(1)
      if(intensity_s/total_intensity>=randomD){
        if(value[1,1]/total_intensity>=randomD){             
          sub_process[[1]]<-rbind(sub_process[[1]],c(s));
          t<-rbind(t,c(s));
          n0<-1
        }
        else{
          for(j in 2:M){
            if ((sum(value[c(1:j-1),1])/total_intensity<randomD)
                &&(sum(value[c(1:j),1])/total_intensity>=randomD)){
              
              t<-rbind(t,c(s));
              sub_process[[j]]<-rbind(sub_process[[j]],c(s));
              n0<-j;
            }
          }
        }
        break; 
      }
      else{
        total_intensity<-sum(value);
        s<-s-log(runif(1))/total_intensity;
        print(s)
        if(s>T){
          out_range<-TRUE;
          break;
        }
      }
    }
    
    #Update the index
    total_index<-total_index+1;
    sub_index[1,n0]<-sub_index[1,n0]+1;
  }
  
  #Remove the entry t=0 in sub_process
  for(i in 1:M){
    if (sub_process[[i]][1,1]==0)
      sub_process[[i]]=as.matrix(sub_process[[i]][-1,])
  }
  return (list(t,sub_process));
}

#______________________________________________________________________________

MultivariateHawkesPlot<-function(history,mu,alpha,beta){
  
  #Given the history of a multivariate hawkes process, draw the plot
  
  process=history[[1]];
  sub_process=history[[2]];
  number=length(sub_process);
  time=seq(0,max(process),by=0.1);
  y<-array();
  
  for(i in 1:length(time)){
    y<-rbind(y,c(MultivariateHawkesLambdaValue(time[i],process,sub_process,mu,alpha,beta)));
  }
  
  y=y[-1,]
  matplot(time,cbind(y[,1],y[,2]),type='l',xlab="Time",ylab="Intensity",lwd=2,cex.axis=1.5,cex.lab=1.5)
  legend("topleft",c("Dim 1","Dim 2"),lty=1:2,col=c(1,2))
}

#______________________________________________________________________________


MultivariateHawkesLikelihood<-function(theta,points,process_dim)
{
  
  #mu:background intensity M x 1 matrix
  #alpha,beta: M x M matrix, with rows i being the parameters of process i
  #Get parameters
  M<-process_dim
  mu<-matrix(theta[1:M],M,1);
  #print(mu)
  alpha<-matrix(theta[(M+1):(M^2+M)],M,M);
  #beta<-array(c(1,1,1,1),dim=c(2,2));
  beta<-matrix(theta[(M^2+M+1):(2*M^2+M)],M,M);
  
  #Get datas
  #points:dataset,type list, with list 1 being the total time(Nx1 matrix), and list2 being a list of the time of subprocesses
  t<-points[[1]]; 
  sub_process<-list();
  
  for(m in 1:M){
    sub_process[[m]]<-points[[2]][[m]];
  }
  
  #datanum_sub: M x 1 matrix to store the length of total process and sub processes
  #datanum_total: 1 x 1 matrix to store the length of total process
  datanum_sub<-matrix(0,M,1);
  for(m in 1:M)
  {
    datanum_sub[m,1]<-dim(sub_process[[m]])[1];
  }
  datanum_total<-dim(t)[1];
  
  #calculate R cubic
  dimR<-max(datanum_sub);
  R<-array(NaN,c(M,M,dimR));
  #Set the first floor of R as zero
  R[,,1]<-0;
  #fill the R matrix
  for(m in 1:M){
    for(n in 1:M){
      if(m!=n){
        for(i in 2:datanum_sub[m,1]){
          temp_sum<-0;
          for(k in 1:datanum_sub[n,1]){
            if(sub_process[[n]][k,1]>=sub_process[[m]][i,1]){break;}
            if((sub_process[[n]][k,1]>=sub_process[[m]][i-1,1])
               &&(sub_process[[n]][k,1]<sub_process[[m]][i,1])){
              temp_sum<-temp_sum+exp(-beta[m,n]*(sub_process[[m]][i,1]-sub_process[[n]][k,1]));
            }
          }
          R[m,n,i]<-exp(-beta[m,n]*(sub_process[[m]][i,1]-sub_process[[m]][i-1,1]))*R[m,n,i-1]+temp_sum;
        }
      }
      else{
        for(i in 2:datanum_sub[m,1]){
          R[m,n,i]<-exp(-beta[m,n]*(sub_process[[m]][i,1]-sub_process[[m]][i-1,1]))*(R[m,n,i-1]+1);
        }
      }
    }
  }
  #R filled
  #Begin calculate likelihood for each coordinate
  #sub_le is a M x 1 matrix to store the likelihood of each coordinate
  
  sub_le<-matrix(0,M,1);
  T<-t[datanum_total,1];
  
  for(m in 1:M){
    part1<-0;
    #for(i in 1:datanum_sub[m])#datanum_total
    #{
    #    for(n in 1:M)
    #    {
    #        part1<-part1+alpha[m,n]/beta[m,n]*(1-exp(-beta[m,n]*(T-sub_process[[m]][i,1])));#t[i,1]
    #    }
    #}
    for(n in 1:M){
      for(i in 1:datanum_sub[n]){
        part1<-part1+alpha[m,n]/beta[m,n]*(1-exp(-beta[m,n]*(T-sub_process[[n]][i,1])));#t[i,1]
      }
    }
    
    part2<-0;
    for(i in 2:datanum_sub[m]){
      temp_sum<-0;
      for(n in 1:M){
        temp_sum<-temp_sum+alpha[m,n]*R[m,n,i];
      }
      part2<-part2+log(mu[m,1]+temp_sum);            
    }
    #print(part2)
    sub_le[m,1]<--mu[m,1]*T-part1+part2;
  }
  
  return (sum(sub_le)); 
}

#______________________________________________________________________________

MultivariateHawkesMLEhin<-function(theta,points,process_dim)
{
  
  M<-process_dim
  mu<-theta[1:M];
  alpha<-theta[(M+1):(M^2+M)];
  #beta<-array(c(1,1,1,1),dim=c(2,2));
  beta<-theta[(M^2+M+1):(2*M^2+M)]
  gamma<-1-theta[(M+1):(M^2+M)]/theta[(M^2+M+1):(2*M^2+M)];
  h<-c(gamma,mu,alpha,beta)
  h;
}

# par<-constrOptim.nl(par=theta,fn=MultiHawkesLikelihood,hin=MLEhin,
#                     control.optim=list(trace=0,fnscale=-0.01),points=x,process_dim=M);

#______________________________________________________________________________


BivairateHawkesLikelihood<-function(theta,points)
{
  
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-theta[7];beta_2<-theta[8]    
  #points:dataset,type list, with list 1 being the total time(Nx1 matrix), and list2 being a list of the time of subprocesses
  t<-points[[1]]; 
  #sub_process<-list();
  t1<-points[[2]][[1]];
  N<-dim(t1)[1];
  t2<-points[[2]][[2]];
  #print(t2)
  M<-dim(t2)[1];
  datanum_total<-dim(t)[1];
  
  #calculate R cubic
  R_11<-matrix(NaN,N,1);
  R_12<-matrix(NaN,N,1);
  R_21<-matrix(NaN,M,1);
  R_22<-matrix(NaN,M,1);
  
  #Set the first floor of R as zero
  R_11[1,1]<-0;R_12[1,1]<-0;R_21[1,1]<-0;R_22[1,1]<-0;
  #fill the R matrix
  for(i in 2:N)
  {
    R_11[i,1]<-(1+R_11[i-1,1])*(exp(-beta_1*(t1[i,1]-t1[i-1,1])));   
  }
  
  for(i in 2:N)
  {
    temp_sum<-0;
    for(j in 1:M)
    {
      if(t2[j,1]>=t1[i,1]){break;}
      if(t2[j,1]>=t1[i-1,1]&&t2[j,1]<t1[i,1]){temp_sum<-temp_sum+exp(-beta_1*(t1[i,1]-t2[j,1]));}
    }
    #print(R_12[i-1,1]*exp(-beta_1*(t1[i,1]-t1[i-1,1])))
    R_12[i,1]<-R_12[i-1,1]*exp(-beta_1*(t1[i,1]-t1[i-1,1]))+temp_sum;
  }
  
  for(j in 2:M)
  {
    R_22[j,1]<-(1+R_22[j-1,1])*(exp(-beta_2*(t2[j,1]-t2[j-1,1])));
  }
  
  for(j in 2:M)
  {
    temp_sum<-0;
    for(i in 1:N)
    {
      if(t1[i,1]>=t2[j,1]){break;}
      if(t1[i,1]>=t2[j-1,1]&&t1[i,1]<t2[j,1]){temp_sum<-temp_sum+exp(-beta_2*(t2[j,1]-t1[i,1]));}
    }
    R_21[j,1]<-R_21[j-1,1]*exp(-beta_2*(t2[j,1]-t2[j-1,1]))+temp_sum;
  }
  
  #R filled
  #Begin calculate likelihood for each coordinate
  
  T<-t[datanum_total,1];
  
  #Calculate L1
  part1<-0;
  part2<-0;
  part3<-0;
  #part1
  for(i in 2:N)
  {
    part1<-part1+log(mu_1+alpha_11*R_11[i,1]+alpha_12*R_12[i,1]);
  }
  #print(part1)
  #part2
  for(i in 1:N)
  {
    part2<-part2+(1-exp(-beta_1*(T-t1[i,1])));
  }
  part2<-part2*alpha_11/beta_1;
  #part3
  for(j in 1:M)
  {
    part3<-part3+(1-exp(-beta_1*(T-t2[j,1])));
  }
  part3<-part3*alpha_12/beta_1;
  L1<-part1-mu_1*T-part2-part3;
  
  #Calculate L2
  part1<-0;
  part2<-0;
  part3<-0;
  #part1
  for(j in 2:M)
  {
    part1<-part1+log(mu_2+alpha_21*R_21[j,1]+alpha_22*R_22[j,1]);
  }
  #print(part1)
  #part2
  for(j in 1:M)
  {
    part2<-part2+(1-exp(-beta_2*(T-t2[j,1])));
  }
  part2<-part2*alpha_22/beta_2;
  #part3
  for(i in 1:N)
  {
    part3<-part3+(1-exp(-beta_2*(T-t1[i,1])));
  }
  part3<-part3*alpha_21/beta_2;
  L2<-part1-mu_2*T-part2-part3;
  L<-L1+L2
  
  return (L);
}


#______________________________________________________________________________

BivariateHawkesMLEhin<-function(theta,points){
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-theta[7];beta_2<-theta[8] 
  h<-c(mu_1,mu_2,alpha_11,alpha_12,alpha_21,alpha_22,beta_1,beta_2,
       1-alpha_11/beta_1,1-alpha_12/beta_1,1-alpha_21/beta_2,1-alpha_22/beta_2);
  h;
}

#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed<-function(theta,points)
{
  #     print('begin likelihood')
  #To calculate the lkelihood value given certain parameters, with beta fixed
  
  #Set the beta value to be 1
  beta_value=1;
  
  #Initialze the parameter value
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value;   
  
  #points:    list 1: total time(Nx1 matrix), 
  #           list 2: time of subprocesses
  
  t<-points[[1]]; 
  t1<-points[[2]][[1]];
  t2<-points[[2]][[2]];
  
  #N: total points number of sub process 1
  N<-dim(t1)[1];
  
  #M: total points number of sub process 2
  M<-dim(t2)[1];
  
  #datanum_total: total points number of superpositioned process
  datanum_total<-dim(t)[1];
  #   print("Initialization finished, begin calculating R")
  
  R_11=array(0,dim=c(N,1))
  R_12=array(0,dim=c(N,1))
  R_21=array(0,dim=c(M,1))
  R_22=array(0,dim=c(M,1))
  
  
  #Set the first floor of R as zero
  R_11[1,1]<-0;R_12[1,1]<-0;R_21[1,1]<-0;R_22[1,1]<-0;
  #fill the R matrix
  for(i in 2:N)
  {
    R_11[i,1]<-(1+R_11[i-1,1])*(exp(-beta_1*(t1[i,1]-t1[i-1,1])));   
  }
  
  for(i in 2:N)
  {
    temp_sum<-0;
    for(j in 1:M)
    {
      if(t2[j,1]>=t1[i,1]){break;}
      if(t2[j,1]>=t1[i-1,1]&&t2[j,1]<t1[i,1]){temp_sum<-temp_sum+exp(-beta_1*(t1[i,1]-t2[j,1]));}
    }
    R_12[i,1]<-R_12[i-1,1]*exp(-beta_1*(t1[i,1]-t1[i-1,1]))+temp_sum;
  }
  
  for(j in 2:M)
  {
    R_22[j,1]<-(1+R_22[j-1,1])*(exp(-beta_2*(t2[j,1]-t2[j-1,1])));
  }
  
  for(j in 2:M)
  {
    temp_sum<-0;
    for(i in 1:N)
    {
      if(t1[i,1]>=t2[j,1]){break;}
      if(t1[i,1]>=t2[j-1,1]&&t1[i,1]<t2[j,1]){temp_sum<-temp_sum+exp(-beta_2*(t2[j,1]-t1[i,1]));}
    }
    R_21[j,1]<-R_21[j-1,1]*exp(-beta_2*(t2[j,1]-t2[j-1,1]))+temp_sum;
  }
  
  #R filled
  #Begin calculate likelihood for each coordinate
  
  #   print("calculating R finished, begin calculating likelihood L1")
  
  T<-t[datanum_total,1];
  #   print(theta)
  L1=-mu_1*T-(alpha_11/beta_1)*sum(1-exp(-beta_1*(T-t1)))-(alpha_12/beta_1)*sum(1-exp(-beta_1*(T-t2)))+sum(log(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #   print("begin calculating likelihood L2")
  L2=-mu_2*T-(alpha_21/beta_2)*sum(1-exp(-beta_2*(T-t1)))-(alpha_22/beta_2)*sum(1-exp(-beta_2*(T-t2)))+sum(log(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  
  L=L1+L2
  #     print('likelihood finished')
  return (L);
}

#______________________________________________________________________________
BivariateHawkesGradient_Beta_Fixed<-function(theta,points){
  #     print('begin gradient')
  #     print('Begin calculating gradient')
  beta_value=1
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value   
  #points:dataset,type list, with list 1 being the total time(Nx1 matrix), and list2 being a list of the time of subprocesses
  t<-points[[1]]; 
  #sub_process<-list();
  t1<-points[[2]][[1]];
  N<-dim(t1)[1];
  t2<-points[[2]][[2]];
  #print(t2)
  M<-dim(t2)[1];
  datanum_total<-dim(t)[1];
  
  #calculate R cubic
  
  R_11=array(0,dim=c(N,1))
  R_12=array(0,dim=c(N,1))
  R_21=array(0,dim=c(M,1))
  R_22=array(0,dim=c(M,1))
  
  #     print('R initialzed')
  #Set the first floor of R as zero
  R_11[1,1]<-0;R_12[1,1]<-0;R_21[1,1]<-0;R_22[1,1]<-0;
  #fill the R matrix
  for(i in 2:N)
  {
    R_11[i,1]<-(1+R_11[i-1,1])*(exp(-beta_1*(t1[i,1]-t1[i-1,1])));   
  }
  
  for(i in 2:N)
  {
    temp_sum<-0;
    for(j in 1:M)
    {
      if(t2[j,1]>=t1[i,1]){break;}
      if(t2[j,1]>=t1[i-1,1]&&t2[j,1]<t1[i,1]){temp_sum<-temp_sum+exp(-beta_1*(t1[i,1]-t2[j,1]));}
    }
    R_12[i,1]<-R_12[i-1,1]*exp(-beta_1*(t1[i,1]-t1[i-1,1]))+temp_sum;
  }
  
  for(j in 2:M)
  {
    R_22[j,1]<-(1+R_22[j-1,1])*(exp(-beta_2*(t2[j,1]-t2[j-1,1])));
  }
  
  for(j in 2:M)
  {
    temp_sum<-0;
    for(i in 1:N)
    {
      if(t1[i,1]>=t2[j,1]){break;}
      if(t1[i,1]>=t2[j-1,1]&&t1[i,1]<t2[j,1]){temp_sum<-temp_sum+exp(-beta_2*(t2[j,1]-t1[i,1]));}
    }
    R_21[j,1]<-R_21[j-1,1]*exp(-beta_2*(t2[j,1]-t2[j-1,1]))+temp_sum;
  }
  
  #R filled
  
  T<-t[datanum_total,1];
  #     print(theta)
  #     print('Calculating Gradient gmu1')
  #Calculate gradient of mu_1,mu_2
  gmu_1=-T+sum(1/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient gmu2')
  
  gmu_2=-T+sum(1/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  
  #Calculate the gradient of alpha
  #     print('Calculating Gradient ga11')
  galpha_11=-sum(1-exp(-beta_1*(T-t1)))/beta_1+sum(R_11[2:N,1]/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient ga12')
  galpha_12=-sum(1-exp(-beta_1*(T-t2)))/beta_1+sum(R_12[2:N,1]/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient ga21')
  galpha_21=-sum(1-exp(-beta_1*(T-t1)))/beta_2+sum(R_21[2:M,1]/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  #     print('Calculating Gradient ga22')
  galpha_22=-sum(1-exp(-beta_1*(T-t2)))/beta_2+sum(R_22[2:M,1]/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  #     print('finisehd calculating gradient')
  g=c(gmu_1,gmu_2,galpha_11,galpha_21,galpha_12,galpha_22)
  #     print('finish grdient')
  #print(g)
  g;
  
}

#______________________________________________________________________________
#compile
cmp_BivariateHawkesLikelihood_Beta_Fixed<- cmpfun(BivariateHawkesLikelihood_Beta_Fixed)
cmp_BivariateHawkesGradient_Beta_Fixed<- cmpfun(BivariateHawkesGradient_Beta_Fixed)

#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed_MLEhin<-function(theta,points)
{
  #Set the beta value to be fixed
  beta_value=1
  
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value; 
  h<-c(mu_1,mu_2,
       alpha_11,alpha_12,alpha_21,alpha_22,
       1-alpha_11/beta_1,1-alpha_12/beta_1,1-alpha_21/beta_2,1-alpha_22/beta_2);
  h;
}



#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed_bynumber_C<-function(theta,points)
{

  #To calculate the lkelihood value given certain parameters, with beta fixed
  
  #Set the beta value to be 1
  beta_value=1;
  
  #Initialze the parameter value
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value;   
  
  #points:    list 1: total time(Nx1 matrix), 
  #           list 2: time of subprocesses
  
  t<-points[[1]]; 
  t1<-points[[2]][[1]];
  t2<-points[[2]][[2]];
  
  #N: total points number of sub process 1
  N<-length(t1);
  
  #M: total points number of sub process 2
  M<-length(t2);
  
  #datanum_total: total points number of superpositioned process
  datanum_total<-length(t);
  #   print("Initialization finished, begin calculating R")
  
  #calculate R cubic
  
  R_11<- .C("R11MatrixCalculation",result=double(N),as.integer(N),as.double(beta_1),as.double(t1))[[1]]
  
  
  R_12<- .C("R12MatrixCalculation",result=double(N),as.integer(N),as.integer(M),as.double(beta_1),as.double(t1),as.double(t2))[[1]]
  
  
  R_21<- .C("R21MatrixCalculation",result=double(M),as.integer(N),as.integer(M),as.double(beta_2),as.double(t1),as.double(t2))[[1]]
  
  
  R_22<- .C("R22MatrixCalculation",result=double(M),as.integer(M),as.double(beta_2),as.double(t2))[[1]]
  
  
  T<-t[datanum_total];
  #   print(theta)
  L1=-mu_1*T-(alpha_11/beta_1)*sum(1-exp(-beta_1*(T-t1)))-(alpha_12/beta_1)*sum(1-exp(-beta_1*(T-t2)))+sum(log(mu_1+alpha_11*R_11[2:N]+alpha_12*R_12[2:N]))
  #   print("begin calculating likelihood L2")
  L2=-mu_2*T-(alpha_21/beta_2)*sum(1-exp(-beta_2*(T-t1)))-(alpha_22/beta_2)*sum(1-exp(-beta_2*(T-t2)))+sum(log(mu_2+alpha_21*R_21[2:M]+alpha_22*R_22[2:M]))
  
  L=L1+L2

  return (L);
}

#______________________________________________________________________________
BivariateHawkesGradient_Beta_Fixed_bynumber_C<-function(theta,points){


  beta_value=1
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value   
  #points:dataset,type list, with list 1 being the total time(Nx1 matrix), and list2 being a list of the time of subprocesses
  t<-points[[1]]; 
  t1<-points[[2]][[1]];
  t2<-points[[2]][[2]];
  
  N<-length(t1);
  M<-length(t2);
  
  #datanum_total: total points number of superpositioned process
  datanum_total<-length(t);
  
  #calculate R cubic
  
  R_11<- .C("R11MatrixCalculation",result=double(N),as.integer(N),as.double(beta_1),as.double(t1))[[1]]
  
  
  R_12<- .C("R12MatrixCalculation",result=double(N),as.integer(N),as.integer(M),as.double(beta_1),as.double(t1),as.double(t2))[[1]]
  
  
  R_21<- .C("R21MatrixCalculation",result=double(M),as.integer(N),as.integer(M),as.double(beta_2),as.double(t1),as.double(t2))[[1]]
  
  
  R_22<- .C("R22MatrixCalculation",result=double(M),as.integer(M),as.double(beta_2),as.double(t2))[[1]]
  
  
  T<-t[datanum_total];

  #Calculate gradient of mu_1,mu_2
  gmu_1=-T+sum(1/(mu_1+alpha_11*R_11[2:N]+alpha_12*R_12[2:N]))
  #     print('Calculating Gradient gmu2')
  
  gmu_2=-T+sum(1/(mu_2+alpha_21*R_21[2:M]+alpha_22*R_22[2:M]))
  
  #Calculate the gradient of alpha

  galpha_11=-sum(1-exp(-beta_1*(T-t1)))/beta_1+sum(R_11[2:N]/(mu_1+alpha_11*R_11[2:N]+alpha_12*R_12[2:N]))

  galpha_12=-sum(1-exp(-beta_1*(T-t2)))/beta_1+sum(R_12[2:N]/(mu_1+alpha_11*R_11[2:N]+alpha_12*R_12[2:N]))

  galpha_21=-sum(1-exp(-beta_1*(T-t1)))/beta_2+sum(R_21[2:M]/(mu_2+alpha_21*R_21[2:M]+alpha_22*R_22[2:M]))

  galpha_22=-sum(1-exp(-beta_1*(T-t2)))/beta_2+sum(R_22[2:M]/(mu_2+alpha_21*R_21[2:M]+alpha_22*R_22[2:M]))

  g=c(gmu_1,gmu_2,galpha_11,galpha_21,galpha_12,galpha_22)

  g;
  
}

#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed_MLEhin_bynumber_C<-function(theta,points)
{
  #Set the beta value to be fixed
  beta_value=1
  
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value; 
  h<-c(mu_1,mu_2,
       alpha_11,alpha_12,alpha_21,alpha_22,
       1-alpha_11/beta_1,1-alpha_12/beta_1,1-alpha_21/beta_2,1-alpha_22/beta_2);
  h;
}


BivariateHawkesLambdaValue_uncmp<-function(time,history,sub_process,mu,alpha,beta)
{
  #Calulate the lambda value of each coordinate at time seconds 
  #value is 1xM matrix to store ambda value of each process
  
  
  value<- array(0,dim=c(2,1));
  
  #   history_before_time<-history[history<=time,];
  #   print('debug_2')
  sub_process_before_time_1<- array(0,dim=c(1,1));
  #   print('debug_3')
  sub_process_before_time_2<- array(0,dim=c(1,1));                          
  
  #trim the sub_process to the length before time
  #   print('debug_4')
  temp_1<- sub_process[[1]][sub_process[[1]]<=time,]
  #   print(head(temp_1))
  
  #   print('debug_5')
  temp_2<- sub_process[[2]][sub_process[[2]]<=time,]
  #   print(head(temp_2))
  
  #coerce as matrix
  #   print('debug_6')
  temp_dim_1<- length(temp_1);
  temp_dim_2<- length(temp_2);
  #   print(temp_dim_1)
  #   print(temp_dim_2)
  
  #   print('debug_7')
  if(temp_dim_1!=0){
    sub_process_before_time_1<- array(temp_1,dim=c(temp_dim_1,1))
    #         print(sub_process_before_time_1)
  }
  #   print('debug_8')
  if(temp_dim_2!=0){
    sub_process_before_time_2<- array(temp_2,dim=c(temp_dim_2,1))
    #         print(sub_process_before_time_2)
  }
  
  #   print('debug_9')
  if(time<history[1,1]){
    #if time is smaller than the first event, the lambda will be mu
    #       print('time<history')
    return (mu);
  }
  else{    
    minus_1<- time-sub_process_before_time_1;
    minus_2<- time-sub_process_before_time_2;
    value[1,1]<- mu[1,1]+alpha[1,1]*sum(exp(-beta[1,1]*minus_1))+alpha[1,2]*sum(exp(-beta[1,2]*minus_2)) 
    
    #     print('debug_11')
    value[2,1]<- mu[2,1]+alpha[2,1]*sum(exp(-beta[2,1]*minus_1))+alpha[2,2]*sum(exp(-beta[2,2]*minus_2))
    #     print(value)
  }
  return (value);
}

#______________________________________________________________________________
#compile the BivariateHawkesLambdaValue_uncmp function
BivariateHawkesLambdaValue<- cmpfun(BivariateHawkesLambdaValue_uncmp);

#______________________________________________________________________________
BivariateHawkesSimulation_uncmp<-function(mu,alpha,beta,T,history=list()){
  
  #simulate a multivariate hawkes process given the history events
  #mu:            background intensity M x 1 matrix
  #history:       If history is not provided(history = 0), the default simulation starts from 0
  #alpha,beta:    M x M matrix, with rows i being the parameters of process i
  #T:             scalar, end time of simulation
  
  #M:             total number of sub processes
  M<- 2;
  
  #Initialization:
  if(length(history)==0){
    
    total_index<- 1;sub_index<- array(1,dim=c(1,2));
    total_intensity<- sum(mu);
    
    #First Event
    s<- -log(runif(1))/total_intensity;
    #t:Store event time:        
    t<- array(0,dim=c(1,1));
    
    #sub_process stores the sub history of each process
    sub_process<- list();
    n0=0;
    for(m in 1:M){
      sub_process[[m]]<- array(0,dim=c(1,1));
    }
    
    if(s>T){return (list(t,sub_process));}
    
    #Attribution test
    randomD<- runif(1);
    if(mu[1,1]/total_intensity>=randomD){
      t[1,1]<- s;
      sub_process[[1]][1,1]<- s;
      n0<- 1;
    }
    else{
      t[1,1]<- s;
      sub_process[[2]][1,1]<- s;
      n0<- 2;
    }
    
    #Update the index
    total_index<- total_index+1;
    sub_index[1,n0]<- sub_index[1,n0]+1;
    
  }
  else{
    #If history is provided, continue simulation from the history
    
    t<- history[[1]]
    sub_process<- list();
    
    #total index counts the number of total events
    #sub index counts the number of sub-process
    
    total_index<- dim(t)[1];
    sub_index<- array(1,dim=c(1,M));
    
    n0<- 0;
    s<- t[total_index,1];
    for(m in 1:2){
      sub_process[[m]]<- history[[2]][[m]];
      sub_index[1,m]<- dim(sub_process[[m]])[1];
    }
    
    #Set the termination time
    T<- t[total_index,1]+T;
    total_index<- total_index+1;
  }
  
  #General Routine
  out_range<- FALSE;
  while(out_range==FALSE){
    
    total_intensity<- sum(BivariateHawkesLambdaValue(t[total_index-1,1],t,sub_process,mu,alpha,beta))+sum(alpha[,n0]);
    
    #Sample a exponential r.v 
    #If X has a standard uniform distribution, Y = − ln(X) / λ has an exponential distribution with rate λ
    s<- s-log(runif(1))/total_intensity;
    #If the sampled r.v is larger than the required length T
    if(s>T){break;}
    
    while(out_range==FALSE){
      
      #Attribution - Rejection test
      value<- BivariateHawkesLambdaValue(s,t,sub_process,mu,alpha,beta);
      intensity_s<- sum(value);
      randomD<- runif(1)
      
      if(value[1,1]/total_intensity>=randomD){           
        sub_process[[1]]<- rbind(sub_process[[1]],c(s));
        t<- rbind(t,c(s));
        n0<- 1
        break;
      }
      else if(value[1,1]/total_intensity<=randomD
              &&sum(value)/total_intensity>=randomD){
        t<- rbind(t,c(s));
        sub_process[[2]]<- rbind(sub_process[[2]],c(s));
        n0<- 2;
        break; 
      }
      else{
        total_intensity<- sum(value);
        s<- s-log(runif(1))/total_intensity;
        if(s>T){
          out_range<- TRUE;
          break;
        }
      }
      
      #end of inner while      
    }
    
    #Update the index
    total_index<- total_index+1;
    sub_index[1,n0]<- sub_index[1,n0]+1;
    
    #end of outter while
  }
  
  #Remove the entry t=0 in sub_process
  for(i in 1:2){
    if (sub_process[[i]][1,1]==0)
      sub_process[[i]]<- as.matrix(sub_process[[i]][-1,])
  }
  return (list(t,sub_process));
}

#______________________________________________________________________________
#Compile BivariateHawkesSimulation_uncmp
BivariateHawkesSimulation<- cmpfun(BivariateHawkesSimulation_uncmp)

BivariateHawkesLambdaValue_bynumber<-function(time,total_index,subIndex1,subIndex2,
                                              t,sub_process1,sub_process2,mu,alpha,beta)
{
  #Calulate the lambda value of each coordinate at time seconds 
  #value is 2X1 matrix to store ambda value of each process
  
  value<- array(0,dim=c(2,1));
  minus_1<- time-sub_process1[1:max(subIndex1,1)];
  minus_2<- time-sub_process2[1:max(subIndex2,1)];
  if(subIndex1<=1){value[1,1]=mu[1,1];}
  else{
    value[1,1]<- mu[1,1]+alpha[1,1]*sum(exp(-beta[1,1]*minus_1))+alpha[1,2]*sum(exp(-beta[1,2]*minus_2)) 
  }
  
  if(subIndex2<=1){value[2,1]=mu[2,1];}
  else{    
    value[2,1]<- mu[2,1]+alpha[2,1]*sum(exp(-beta[2,1]*minus_1))+alpha[2,2]*sum(exp(-beta[2,2]*minus_2))
  }
  
  print(value)
  
  return (value);
}


#______________________________________________________________________________
BivariateHawkesSimulation_bynumber<-function(dataNumber,mu,alpha,beta,history=list())
{
  
  #simulate a bivariate hawkes process(dataNumber points) given the history events
  #mu:            background intensity M x 1 matrix
  #history:       If history is not provided(history = 0), the default simulation starts from 0
  #alpha,beta:    M x M matrix, with rows i being the parameters of process i
  
  #M:             total number of sub processes
  
  #Initialization:
  if(length(history)==0){
    
    total_index<- 0;subIndex1<- 0;subIndex2<- 0;
    max_intensity<- sum(mu);
    
    #First Event
    s<- -log(runif(1))/max_intensity;
    #t:Store event time:        
    t<- vector(mode="numeric",length=dataNumber)
    sub_process1<- vector(mode="numeric",dataNumber)
    sub_process2<- vector(mode="numeric",dataNumber)
    #         #sub_process stores the sub history of each process
    #         sub_process<- list();
    n0=0;
    
    #Attribution test
    randomD<- runif(1);
    if(randomD<= mu[1,1]/max_intensity){
      t[1]<- s;
      sub_process1[1]<- s;
      n0<- 1;
      subIndex1<- subIndex1+1;
      total_index<- total_index+1; 
    }
    else{
      t[1]<- s;
      sub_process2[1]<- s;
      n0<- 2;
      subIndex2<- subIndex2+1;
      total_index<- total_index+1; 
    }
    dataNumber<- dataNumber-1;
  }
  else{
    #If history is provided, continue simulation from the history
    total_index<- length(history[[1]]);
    subIndex1<- length(history[[2]])
    subIndex2<- length(history[[3]])
    
    t<- vector(mode="numeric",length=(dataNumber+total_index))
    sub_process1<- vector(mode="numeric",length=(dataNumber+subIndex1))
    sub_process2<- vector(mode="numeric",length=(dataNumber+subIndex2))
    
    t[1:total_index]<- history[[1]]
    
    sub_process1[1:subIndex1]<- history[[2]]
    sub_process2[1:subIndex2]<- history[[3]]
    
    #total index counts the number of total events
    #sub index counts the number of sub-process
    
    n0<- 0;
    s<- t[total_index];
    
    #Set the termination time
    dataNumber<- dataNumber+total_index
#     total_index<- total_index+1;
  }
  
  #General Routine
  for(i in total_index:dataNumber){
    
    #     while(out_range==FALSE){
    rate<- BivariateHawkesLambdaValue_bynumber(t[total_index],total_index,subIndex1,subIndex2,t,sub_process1,sub_process2,mu,alpha,beta)
    
    max_intensity<- sum(rate)+sum(alpha[,n0]);
    
    #Sample a exponential r.v 
    #If X has a standard uniform distribution, Y = − ln(X) / λ has an exponential distribution with rate λ
    
    while(T){
      s<- s-log(runif(1))/max_intensity;
      value<- BivariateHawkesLambdaValue_bynumber(s,total_index,subIndex1,subIndex2,t,sub_process1,sub_process2,mu,alpha,beta);
      intensity_s<- sum(value);
      randomD<- runif(1)
      
      #Attribution - Rejection test
      if(randomD <= intensity_s/max_intensity){
        total_index<- total_index+1;
        t[total_index]<- s
        if(randomD<= (value[1,1]/max_intensity)){
          subIndex1<- subIndex1+1
          sub_process1[subIndex1]<- s;
          n0<- 1
        }
        else{
          subIndex2<- subIndex2+1
          sub_process2[subIndex2]<- s;
          n0<- 2;
        }
        break; 
      }
      else{
        max_intensity<- intensity_s;
      }
      
      #end of inner while loop
    }
  }
  sub_process1<- sub_process1[1:subIndex1]
  sub_process2<- sub_process2[1:subIndex2]
  
  return (list(t,sub_process1,sub_process2));
}


#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed_C<-function(theta,points)
{
  print('begin likelihood')
  #To calculate the lkelihood value given certain parameters, with beta fixed
  
  #Set the beta value to be 1
  beta_value=1;
  
  #Initialze the parameter value
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value;   
  
  #points:    list 1: total time(Nx1 matrix), 
  #           list 2: time of subprocesses
  
  t<-points[[1]]; 
  t1<-points[[2]][[1]];
  t2<-points[[2]][[2]];
  
  #N: total points number of sub process 1
  N<-dim(t1)[1];
  
  #M: total points number of sub process 2
  M<-dim(t2)[1];
  
  #datanum_total: total points number of superpositioned process
  datanum_total<-dim(t)[1];
  #   print("Initialization finished, begin calculating R")
  
  #calculate R cubic
  
  R_11<- .C("R11MatrixCalculation",result=double(N),as.integer(N),as.double(beta_1),as.double(t1))[[1]]
  
  
  R_12<- .C("R12MatrixCalculation",result=double(N),as.integer(N),as.integer(M),as.double(beta_1),as.double(t1),as.double(t2))[[1]]
  
  
  R_21<- .C("R21MatrixCalculation",result=double(M),as.integer(N),as.integer(M),as.double(beta_2),as.double(t1),as.double(t2))[[1]]
  
  
  R_22<- .C("R22MatrixCalculation",result=double(M),as.integer(M),as.double(beta_2),as.double(t2))[[1]]
  
  
  R_11<- matrix(R_11,ncol=1);
  R_12<- matrix(R_12,ncol=1);
  R_21<- matrix(R_21,ncol=1);
  R_22<- matrix(R_22,ncol=1);
  
  T<-t[datanum_total,1];
  #   print(theta)
  L1=-mu_1*T-(alpha_11/beta_1)*sum(1-exp(-beta_1*(T-t1)))-(alpha_12/beta_1)*sum(1-exp(-beta_1*(T-t2)))+sum(log(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #   print("begin calculating likelihood L2")
  L2=-mu_2*T-(alpha_21/beta_2)*sum(1-exp(-beta_2*(T-t1)))-(alpha_22/beta_2)*sum(1-exp(-beta_2*(T-t2)))+sum(log(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  
  L=L1+L2
  print('likelihood finished')
  return (L);
}

#______________________________________________________________________________
BivariateHawkesGradient_Beta_Fixed_C<-function(theta,points){
  print('begin gradient')
  #     print('Begin calculating gradient')
  beta_value=1
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value   
  #points:dataset,type list, with list 1 being the total time(Nx1 matrix), and list2 being a list of the time of subprocesses
  t<-points[[1]]; 
  #sub_process<-list();
  t1<-points[[2]][[1]];
  N<-dim(t1)[1];
  t2<-points[[2]][[2]];
  #print(t2)
  M<-dim(t2)[1];
  datanum_total<-dim(t)[1];
  
  #calculate R cubic
  
  R_11<- .C("R11MatrixCalculation",result=double(N),as.integer(N),as.double(beta_1),as.double(t1))[[1]]
  
  
  R_12<- .C("R12MatrixCalculation",result=double(N),as.integer(N),as.integer(M),as.double(beta_1),as.double(t1),as.double(t2))[[1]]
  
  
  R_21<- .C("R21MatrixCalculation",result=double(M),as.integer(N),as.integer(M),as.double(beta_2),as.double(t1),as.double(t2))[[1]]
  
  
  R_22<- .C("R22MatrixCalculation",result=double(M),as.integer(M),as.double(beta_2),as.double(t2))[[1]]
  
  
  R_11<- matrix(R_11,ncol=1);
  R_12<- matrix(R_12,ncol=1);
  R_21<- matrix(R_21,ncol=1);
  R_22<- matrix(R_22,ncol=1);
  #R filled
  
  T<-t[datanum_total,1];
  #     print(theta)
  #     print('Calculating Gradient gmu1')
  #Calculate gradient of mu_1,mu_2
  gmu_1=-T+sum(1/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient gmu2')
  
  gmu_2=-T+sum(1/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  
  #Calculate the gradient of alpha
  #     print('Calculating Gradient ga11')
  galpha_11=-sum(1-exp(-beta_1*(T-t1)))/beta_1+sum(R_11[2:N,1]/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient ga12')
  galpha_12=-sum(1-exp(-beta_1*(T-t2)))/beta_1+sum(R_12[2:N,1]/(mu_1+alpha_11*R_11[2:N,1]+alpha_12*R_12[2:N,1]))
  #     print('Calculating Gradient ga21')
  galpha_21=-sum(1-exp(-beta_1*(T-t1)))/beta_2+sum(R_21[2:M,1]/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  #     print('Calculating Gradient ga22')
  galpha_22=-sum(1-exp(-beta_1*(T-t2)))/beta_2+sum(R_22[2:M,1]/(mu_2+alpha_21*R_21[2:M,1]+alpha_22*R_22[2:M,1]))
  #     print('finisehd calculating gradient')
  g=c(gmu_1,gmu_2,galpha_11,galpha_21,galpha_12,galpha_22)
  print('finish grdient')
  #print(g)
  g;
  
}

#______________________________________________________________________________

BivariateHawkesLikelihood_Beta_Fixed_MLEhin_C<-function(theta,points)
{
  #Set the beta value to be fixed
  beta_value=1
  
  mu_1<-theta[1];mu_2<-theta[2];
  alpha_11<-theta[3];alpha_12<-theta[5];alpha_21<-theta[4];alpha_22<-theta[6];
  beta_1<-beta_value;beta_2<-beta_value; 
  h<-c(mu_1,mu_2,
       alpha_11,alpha_12,alpha_21,alpha_22,
       1-alpha_11/beta_1,1-alpha_12/beta_1,1-alpha_21/beta_2,1-alpha_22/beta_2);
  h;
}


